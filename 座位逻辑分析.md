# 座位逻辑分析报告

## 座位状态定义
- **0** = 可用
- **1** = 锁定（订单待支付，15分钟后过期）
- **2** = 已售（订单已支付）

## 业务流程与座位逻辑检查

### 1. 购票流程 ✅
**位置**: `OrderServiceImpl.createOrder()` (第95-98行)
```java
seat.setSeatStatus((byte) 1);  // 0 → 1 锁定
seat.setLockExpireTime(LocalDateTime.now().plusMinutes(15));
```
- **操作**: 创建订单时锁定座位
- **座位状态**: 0（可用） → 1（锁定）
- **可用座位数**: -1 ✅ 符合预期

---

### 2. 取消支付（取消订单）✅
**位置**: `OrderServiceImpl.cancelOrder()` (第224-227行)
```java
if (seat != null && seat.getSeatStatus() == 1) {
    seat.setSeatStatus((byte) 0);  // 1 → 0 释放
    seat.setLockExpireTime(null);
}
```
- **操作**: 取消待支付订单，释放锁定的座位
- **座位状态**: 1（锁定） → 0（可用）
- **可用座位数**: +1 ✅ 符合预期

---

### 3. 支付成功 ✅
**位置**: `OrderServiceImpl.payOrder()` (第193-196行)
```java
if (seat != null && seat.getSeatStatus() == 1) {
    seat.setSeatStatus((byte) 2);  // 1 → 2 已售
    seat.setLockExpireTime(null);
}
```
- **操作**: 支付成功，将锁定座位改为已售
- **座位状态**: 1（锁定） → 2（已售）
- **可用座位数**: 不变（已在购票时-1）✅ 符合预期

---

### 4. 退票 ✅
**位置**: `OrderServiceImpl.refundOrder()` (第296-299行)
```java
Seat seat = seatMapper.findById(ticket.getSeatId());
if (seat != null && seat.getSeatStatus() == 2) {
    seat.setSeatStatus((byte) 0);  // 2 → 0 释放
    seat.setLockExpireTime(null);
}
```
- **操作**: 退票时释放已售座位
- **座位状态**: 2（已售） → 0（可用）
- **可用座位数**: +1 ✅ 符合预期

---

### 5. 改签 ✅
**位置**: `OrderServiceImpl.changeOrder()` (第369-376行 + 第349-352行)

#### 释放原车次座位
```java
for (Ticket oldTicket : oldTickets) {
    Seat oldSeat = seatMapper.findById(oldTicket.getSeatId());
    if (oldSeat != null && oldSeat.getSeatStatus() == 2) {
        oldSeat.setSeatStatus((byte) 0);  // 2 → 0 释放
        oldSeat.setLockExpireTime(null);
    }
}
```
- **原车次座位状态**: 2（已售） → 0（可用）
- **原车次可用座位数**: +1 ✅

#### 锁定新车次座位
```java
seat.setSeatStatus((byte) 2);  // 0 → 2 直接已售
seat.setLockExpireTime(null);
```
- **新车次座位状态**: 0（可用） → 2（已售）
- **新车次可用座位数**: -1 ✅

**综合**: 原车次+1，新车次-1 ✅ 符合预期

---

## 前端逻辑检查

### 前端只调用API，不处理座位逻辑 ✅

#### 1. 取消订单
**文件**: `OrderList/index.jsx` (第35-42行)
```javascript
const handleCancelOrder = useCallback(async (orderId) => {
  try {
    await dispatch(cancelOrder(orderId)).unwrap()
    message.success('订单已取消')
  } catch (error) {
    message.error('取消订单失败')
  }
}, [dispatch, loadOrders])
```
- ✅ 只调用API，座位逻辑由后端处理

#### 2. 退票
**文件**: `RefundChange/index.jsx` (第345-398行)
```javascript
const response = await refundOrder(selectedOrder.id, {
  reason: '用户主动退票'
})
```
- ✅ 只调用API，座位逻辑由后端处理

#### 3. 改签
**文件**: `RefundChange/index.jsx` (第413-507行)
```javascript
const response = await changeOrder(selectedOrder.id, {
  newTripId: values.newTripId,
  newTripNo: selectedTrip.tripNumber || selectedTrip.tripNo,
  ...
})
```
- ✅ 只调用API，座位逻辑由后端处理

---

## 总结

### ✅ 所有逻辑符合预期

| 操作 | 座位状态变化 | 可用座位数变化 | 实现位置 | 状态 |
|------|-------------|--------------|----------|------|
| 购票 | 0 → 1 | -1 | OrderServiceImpl.createOrder() | ✅ 正确 |
| 取消支付 | 1 → 0 | +1 | OrderServiceImpl.cancelOrder() | ✅ 正确 |
| 支付成功 | 1 → 2 | 不变 | OrderServiceImpl.payOrder() | ✅ 正确 |
| 退票 | 2 → 0 | +1 | OrderServiceImpl.refundOrder() | ✅ 正确 |
| 改签（原车次） | 2 → 0 | +1 | OrderServiceImpl.changeOrder() | ✅ 正确 |
| 改签（新车次） | 0 → 2 | -1 | OrderServiceImpl.changeOrder() | ✅ 正确 |

### 前端职责
前端**只负责调用API**，不处理任何座位逻辑，所有座位状态管理由后端完成。

### 注意事项
1. **座位锁定过期机制**: 购票时座位锁定15分钟，超时后应释放（需要定时任务处理）
2. **并发控制**: 座位锁定和释放需要数据库层面的乐观锁或悲观锁
3. **事务一致性**: 所有操作都使用`@Transactional`保证原子性

### 建议
考虑添加定时任务清理过期的锁定座位：
```java
@Scheduled(fixedRate = 60000) // 每分钟执行一次
public void releaseExpiredSeats() {
    seatMapper.releaseExpiredLocks(LocalDateTime.now());
}
```
